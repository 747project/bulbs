# Watch out for using Blueprints methods that have internal transactions.
# You'll get better write performance with only using one transaction.
# In other words, don't use:
#  ElementHelper.removeProperties() and ElementHelper.setProperties()
# Don't use Gremlin methods for writes because all contain transactions.
# Actually, Neo4j doesn't support nested transactions -- it ignores
# internal transactions
# http://wiki.neo4j.org/content/Transactions
# http://wiki.neo4j.org/content/Flat_nested_transactions

# index_name, keys
create_vertex_index: |
  manager = g.index()
  index = manager.forNodes('$index_name')
  // values stored as strings, so keys are stored as json or "null"
  manager.setConfiguration(index,"keys",$keys)
  
get_vertex_index: |
  IndexManager manager = g.index()
  Index<Node> index = manager.forNodes('$index_name')
  Map<String, String> config = manager.getConfiguration(index) 
  
# indent: C-u 4 C-x TAB, remove indent C-u -4 C-x TAB
create_indexed_vertex: | 
  def create_indexed_vertex(data,index_name,keys) {
      manager = g.getRawGraph().index()
      index = manager.forNodes(index_name)
      g.setMaxBufferSize(0)
      g.startTransaction()
      vertex = g.getRawGraph().createNode()
      for (entry in data.entrySet()) {
          if (entry.value == null) continue;
              vertex.setProperty(entry.key,entry.value)
          if (keys == null || keys.contains(entry.key))
              index.add(vertex,entry.key,entry.value)
      }
      g.stopTransaction(TransactionalGraph.Conclusion.SUCCESS)
      return vertex
    }


# data, index_name, keys
create_indexed_vertex_old: |

  manager = g.getRawGraph().index()
  index = manager.forNodes(index_name)
  g.setMaxBufferSize(0)
  g.startTransaction()
  vertex = g.getRawGraph().createNode()
  for (entry in data.entrySet()) {
    if (entry.value == null) continue;
    vertex.setProperty(entry.key,entry.value)
    if (keys == null || keys.contains(entry.key))
        index.add(vertex,entry.key,entry.value)
  }
  g.stopTransaction(TransactionalGraph.Conclusion.SUCCESS)
  return vertex

# _id, data, index_name, keys
update_indexed_vertex: |
  vertex = g.getRawGraph().getNodeById(_id)
  manager = g.getRawGraph().index()
  index = manager.forNodes(index_name)
  g.setMaxBufferSize(0)
  g.startTransaction()
  index.remove(vertex)
  for (String key in vertex.getPropertyKeys())
    vertex.removeProperty(key)
  for (entry in data.entrySet()) {
    if (entry.value == null) continue;
    vertex.setProperty(entry.key,entry.value)
    if (keys == null || keys.contains(entry.key))
        index.add(vertex,entry.key,entry.value)
  }
  g.stopTransaction(TransactionalGraph.Conclusion.SUCCESS)
  return vertex
  
